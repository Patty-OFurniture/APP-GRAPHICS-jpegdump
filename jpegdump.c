/*
   jpegdump.c - dump JPEG marker information

   v1.00  1992.06.09  initial release
   v1.01  1992.06.22  non-JFIF APP0 markers didn't display first five bytes
   v1.02  1992.07.20  eliminated fseeks which seem to be broken, even for
                      forward seeks only, on pipes on some systems
   v1.03  1992.08.24  added offset and stop at eoi options
   v1.04  1992.08.24  added parsing of JFIF extension markers as per JFIF
                      v1.02 draft of 1992.08.21
   v1.05  1992.08.25  added -r to recurse into JPEG compressed thumbnails
                      (completely untested; probably doesn't work)
   v1.06  1992.09.14  incorporated Phil Richards' code to guess cjpeg quality
                      factor
   v1.07  1992.09.15  added extension 0x13 per final JFIF 1.02; repaired bugs
                      in thumbnail-related code
   v1.08  1992.12.23  Provide multiple levels of verbosity; miscellaneous
                      cleanups
   v1.09  1993.03.01  Add switch for hex/char printout of COM,APPn data
   v1.10  1993.10.26  Identify -q 100 quant tables correctly; more tweaking
                      of verbosity levels
          1994.10.18  Report pad bytes and extraneous data between markers
   v1.11  1995.09.23  Include JPEG process name in terse output for SOFn
   v1.12  1995.11.22  Print DQT tables in normal array order, not zigzag order
   v1.13  1996.05.31  Handle JPEG Part 3 extension markers, including SPIFF.
                      Add summary table printout for DHT tables, tweak
                      verbosity some more.  Detect out-of-order RSTn markers.
   v1.14  1997.05.11  Do some elementary formatting of Adobe APP13 markers.
                      You'll need the Photoshop SDK documentation to make
                      any sense of these, though.

Copyright (c) 1992 Handmade Software, Inc.
by Allan N. Hessenflow

Permission to use, copy, modify, and distribute this software and
its documentation for any purpose and without fee is hereby granted,
provided that the above copyright notice appear in all copies and
that both that copyright notice and this permission notice appear in
supporting documentation.  This software is provided "as is" without
express or implied warranty.


Usage:
  jpegdump [-help] [-q] [-v] [-o n] [-c] [-noc] [-r] [-nor] [-hex] [-nohex]
           [file1 [file2...]]

  -q       quiet: minimal information printed
  -v       verbose: more information printed (multiple -v's give more output)
  -o n     skip first n bytes of file (1234 is decimal, 0x1234 for hex)
  -c       continue past EOI to actual end of file (default)
  -noc     stop upon seeing EOI marker
  -r       recurse into jpeg compressed thumbnails
  -nor     don't recurse into thumbnails (default)
  -hex     show COM and APPn data in hex
  -nohex   show COM and APPn data in ASCII when possible (default)

The numbers printed in the `Approximate quality factor' line are as follows:
  Quality: an estimate of the quality factor used when cjpeg was run.
  Scaling factor (scale): mean ratio between quantization table entries
	and JPEG sample table entries, times 100.
  Variance (var): squared standard deviation of the above ratio.
	If this is larger than about 2, then the table is not a simple
	multiple of the standard's sample table, so the file was NOT
	generated by cjpeg and the quality estimate is dubious.

Verbosity levels:
  -q        one-line summary of SOF parameters
  default   SOF parameters and qtable quality factor estimates
  -v        Show all markers except RSTn; no contents of DQT or DHT tables
  -v -v     Also show actual contents of DQT tables
  3 -v's    Also show summary of DHT table contents
  4 -v's    Also show exact contents of DHT tables
  5 -v's    Also report all RSTn markers
A recursed-into thumbnail is shown at one verbosity level less than the
main image.

Bugs:
  garbage in, garbage out


Build instructions:
     MSC v7.00 (substitute the path to setargv.obj for \c700\lib\):
       cl jpegdump.c \c700\lib\setargv.obj /link /NOE
     Watcom C/386 v9.0 (substitute the path to wildargv.c for \watcom\src\starup\)
       wcl386 jpegdump.c \watcom\src\startup\wildargv.c
     acc:
       acc jpegdump.c -o jpegdump
     gcc:
       gcc jpegdump.c -o jpegdump
     others:
       any ANSI C compiler should work.  If you don't define CASESENSITIVE
       then you may need to provide your own strnicmp on some systems; this
       is just a case insensitive version of strncmp.  If you're too lazy
       to do that, just define CASESENSITIVE and be sure to enter the
       switches in lower case.


Bug reports, comments to:
     allanh@netcom.com
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#ifdef MSDOS
#include <fcntl.h>		/* for setmode() call */
#endif

#ifdef CASESENSITIVE		/* set to disable use of strnicmp */
#define strnicmp(a,b,len)	strncmp(a,b,len)
#endif


/* JPEG marker codes */
#define TEM  0x01
#define SOF  0xc0
#define DHT  0xc4
#define JPGA 0xc8
#define DAC  0xcc
#define RST  0xd0
#define SOI  0xd8
#define EOI  0xd9
#define SOS  0xda
#define DQT  0xdb
#define DNL  0xdc
#define DRI  0xdd
#define DHP  0xde
#define EXP  0xdf
#define APP  0xe0
#define COM  0xfe
/* marker codes added by JPEG Part 3 extensions */
#define VER  0xf0
#define DTI  0xf1
#define DTT  0xf2
#define SRF  0xf3
#define SRS  0xf4
#define DCR  0xf5
#define DQS  0xf6

/* Sample quantization tables from JPEG spec --- only needed for
 * guesstimate of quality factor.  Note these are in zigzag order.
 */
static int std_luminance_quant_tbl[64] = {
  16,  11,  12,  14,  12,  10,  16,  14,
  13,  14,  18,  17,  16,  19,  24,  40,
  26,  24,  22,  22,  24,  49,  35,  37,
  29,  40,  58,  51,  61,  60,  57,  51,
  56,  55,  64,  72,  92,  78,  64,  68,
  87,  69,  55,  56,  80, 109,  81,  87,
  95,  98, 103, 104, 103,  62,  77, 113,
 121, 112, 100, 120,  92, 101, 103,  99
};

static int std_chrominance_quant_tbl[64] = {
  17,  18,  18,  24,  21,  24,  47,  26,
  26,  47,  99,  66,  56,  66,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99,
  99,  99,  99,  99,  99,  99,  99,  99
};

static int *deftabs[2] =
    { std_luminance_quant_tbl, std_chrominance_quant_tbl };

/* jpeg_zigzag_order[i] is the zigzag-order position of the i'th element
 * of a DCT block read in natural order (left to right, top to bottom).
 */

static int jpeg_zigzag_order[64] = {
   0,  1,  5,  6, 14, 15, 27, 28,
   2,  4,  7, 13, 16, 26, 29, 42,
   3,  8, 12, 17, 25, 30, 41, 43,
   9, 11, 18, 24, 31, 40, 44, 53,
  10, 19, 23, 32, 39, 45, 52, 54,
  20, 22, 33, 38, 46, 51, 55, 60,
  21, 34, 37, 47, 50, 56, 59, 61,
  35, 36, 48, 49, 57, 58, 62, 63
};


typedef enum {false, true} boolean;

/* switch table */
static struct opt {
  char *string;
  enum { helpO, quietO, verboseO, offsetO, continueO, noContinueO,
	 recurseO, noRecurseO, hexcharsO, nohexcharsO } id;
} options[] = {
  {"?", helpO},
  {"help", helpO},
  {"quiet", quietO},
  {"verbose", verboseO},
  {"offset", offsetO},
  {"continueaftereoi", continueO},
  {"nocontinueaftereoi", noContinueO},
  {"recurseintojpegthumbnails", recurseO},
  {"norecurseintojpegthumbnails", noRecurseO},
  {"hex", hexcharsO},
  {"nohex", nohexcharsO}
};

static boolean recurseIntoThumbnails; /* state of recursion switch */
static boolean hexchars;	/* state of hex-chars switch */


static long dumpMarkers(FILE *, char *, int, boolean, long);
static long dumpAPP0Marker(FILE *, char *, int, long, long);
static long dumpAPP8Marker(FILE *, char *, int, long, long, boolean *);
static long dumpAPP13Marker(FILE *, char *, int, long, long);
static unsigned int getWordMoto(FILE *);
static unsigned long getLongMoto(FILE *);
static void printChar (int);
static void printCharNoHex (int);


/* Main program: switch parsing */


int
main (int argc, char **argv)
{
  FILE *inFile;
  int numFileNames;
  int i;
  int verbosity;
  boolean skipeoi;
  long offset, j;
  
  /* default switch settings */
  offset=0L;
  skipeoi=true;
  verbosity=0;
  recurseIntoThumbnails=false;
  hexchars=false;
  
  /* skip invocation name */
  argc--;
  argv++;
  
  /* scan arguments */
  numFileNames=0;

  while (argc) {
    if (**argv=='-'
#ifdef MSDOS
	|| **argv=='/'
#endif
	) {
      /* Process a switch */
      size_t length;
      int selectedOption;
      boolean multipleMatches;
      
      length=strlen((*argv)+1);
      selectedOption=-1;
      multipleMatches=false;
      for (i=0; i<sizeof(options)/sizeof(struct opt); i++) {
	if (strnicmp((*argv)+1, options[i].string, length)==0) {
	  if (selectedOption>=0)
	    if (options[i].id!=options[selectedOption].id)
	      multipleMatches=true;
	  selectedOption=i;
	  if (length==strlen(options[i].string)) {
	    multipleMatches=false;
	    break;
	  }
	}
      }
      if (selectedOption>=0 && !multipleMatches) {
	switch(options[selectedOption].id) {
	case helpO:
	  fprintf(stderr,
		  "usage: jpegdump [-help] [-q] [-v] [-o n] [-c] [-noc] [-r] [-nor] [-hex] [-nohex] [file1 [file2...]]\n");
	  exit(0);
	  break;
	case quietO:
	  verbosity--;
	  break;
	case verboseO:
	  verbosity++;
	  break;
	case offsetO:
	  if (argc>1) {
	    argc--;
	    argv++;
	    offset=strtol(*argv, NULL, 0);
	  }
	  break;
	case continueO:
	  skipeoi=true;
	  break;
	case noContinueO:
	  skipeoi=false;
	  break;
	case recurseO:
	  recurseIntoThumbnails=true;
	  break;
	case noRecurseO:
	  recurseIntoThumbnails=false;
	  break;
	case hexcharsO:
	  hexchars=true;
	  break;
	case nohexcharsO:
	  hexchars=false;
	  break;
	}
      } else if (multipleMatches) {
	fprintf(stderr, "ambiguous option %s\n", *argv);
	exit(-1);
      } else {
	fprintf(stderr, "unrecognized option %s\n", *argv);
	exit(-1);
      }
    } else {
      /* not a switch, process input file with current switch settings */
      numFileNames++;
      inFile=fopen(*argv, "rb");
      if (inFile==NULL) {
	fprintf(stderr, "can't open file %s\n", *argv);
      } else {
	printf("\n%s:\n", *argv);
	for (j=0L; j<offset; j++) /* skip specified offset */
	  getc(inFile);
	dumpMarkers(inFile, "", verbosity, skipeoi, offset);
	fclose(inFile);
      }
    }
    argv++;
    argc--;
  }

  /* Process standard input if no file names were found */
  if (numFileNames==0) {
    inFile=stdin;
#ifdef MSDOS
    /* turn off newline translation */
    setmode(fileno(inFile), O_BINARY);
#endif
    for (j=0L; j<offset; j++)	/* skip specified offset */
      getc(inFile);
    dumpMarkers(inFile, "", verbosity, skipeoi, offset);
  }

  return 0;
}


/* Standard JPEG markers (including Part 3 extensions, other than SPIFF) */


static long
dumpMarkers (FILE *stream, char *prefix, int verbosity,
	     boolean continueAfterEOI, long startingOffset)
{
  int marker;
  int c, c2, c3, c4, c5, i;
  unsigned int height, aword, aword2, aword3, aword4;
  unsigned long along, along2, along3, along4;
  long length;
  long totalBytesRead;
  long extraneousBytes;
  long markerBytes;
  int expectingData, wasExpectingData;
  int nextRSTexpected, thisRSTnum;
  boolean inSPIFFDir;
  char *str;
  char *process;
  
  totalBytesRead=0L;
  extraneousBytes=0L;
  expectingData=0;		/* report extraneous data except after SOS */
  nextRSTexpected = -1;		/* no RST expected now */
  inSPIFFDir = false;

  while (1) {
    c=getc(stream);
    if (c==EOF)
      break;
    totalBytesRead++;
    /* marker prefix? */
    if (c!=0xff) {
      extraneousBytes++;
      continue;
    }
    /* get marker code, skipping fill bytes */
    markerBytes=1L;
    do {
      c=getc(stream);
      totalBytesRead++;
      markerBytes++;
    } while (c==0xff);
    if (c==EOF) {
      totalBytesRead--;
      markerBytes--;
      extraneousBytes += markerBytes;
      break;
    }
    /* ignore stuffed FF/00 sequences */
    if (c==0) {
      extraneousBytes += markerBytes;
      continue;
    }
    /* OK, we've apparently found a marker */
    marker=c;
    /* Gripe about extraneous data between markers */
    if (extraneousBytes) {
      if (!expectingData && verbosity>0)
	printf("%s%ld extraneous bytes between markers\n", prefix, extraneousBytes);
      extraneousBytes=0L;
    }
    /* Tell about padding FFs on a marker, too */
    if (markerBytes != 2L && verbosity>0)
      printf("%s%ld pad FFs before this marker:\n", prefix, markerBytes-2L);
    /* Minimum verbosity to print marker is 0 for non-RST markers */
    /* RSTs have special behavior, see their case */
    if (verbosity>0 && (marker<RST+0 || marker>RST+7))
      printf("%soffset $%lx ", prefix, totalBytesRead+startingOffset-2L);
    wasExpectingData=expectingData;
    expectingData=0;		/* Reset for all except SOS and RST */
    length=0L;
    switch (marker) {
    case SOI:
      if (verbosity>0)
	printf("SOI\n");
      break;
    case DRI:
      length=(long) getWordMoto(stream);
      aword = getWordMoto(stream);
      if (verbosity>0) {
	printf("DRI (length %ld)\n", length);
	printf("%s  restart interval %u MCUs\n", prefix, aword);
      }
      if (aword != 0)
	nextRSTexpected = 0;	/* expecting RSTs now */
      else
	nextRSTexpected = -1;	/* not expecting any RSTs */
      totalBytesRead+=4L;
      length-=4L;
      break;
    case APP+0:
    case APP+1:
    case APP+2:
    case APP+3:
    case APP+4:
    case APP+5:
    case APP+6:
    case APP+7:
    case APP+8:
    case APP+9:
    case APP+10:
    case APP+11:
    case APP+12:
    case APP+13:
    case APP+14:
    case APP+15:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("APP%d (length %ld)\n", marker-APP, length);
      totalBytesRead+=2L;
      length-=2L;
      /* Handle some APP0 markers specially */
      if (marker==APP+0) {
	long bytes;
	bytes=dumpAPP0Marker(stream, prefix, verbosity,
			     startingOffset+totalBytesRead, length);
	totalBytesRead+=bytes;
	length-=bytes;
      } else if (marker==APP+8) {
	long bytes;
	bytes=dumpAPP8Marker(stream, prefix, verbosity,
			     startingOffset+totalBytesRead, length,
			     &inSPIFFDir);
	totalBytesRead+=bytes;
	length-=bytes;
      } else if (marker==APP+13) {
	long bytes;
	bytes=dumpAPP13Marker(stream, prefix, verbosity,
			      startingOffset+totalBytesRead, length);
	totalBytesRead+=bytes;
	length-=bytes;
      }
      /* Print any remaining data in the APP marker */
      if (length) {
	if (verbosity>0)
	  printf("%s  ", prefix);
	while (length>0L) {
	  c = getc(stream);
	  if (verbosity>0)
	    printChar(c);
	  totalBytesRead++;
	  length--;
	}
	if (verbosity>0)
	  printf("\n");
      }
      break;
    case COM:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("COM (length %ld)\n%s  ", length, prefix);
      totalBytesRead+=2L;
      length-=2L;
      while (length>0L) {
	c = getc(stream);
	if (verbosity>0)
	  printChar(c);
	totalBytesRead++;
	length--;
      }
      if (verbosity>0)
	printf("\n");
      break;
    /* the following all have the same syntax and fall through to one parser */
    case SOF+0:
      str="SOF0"; process="Baseline";
      goto frame;
    case SOF+1:
      str="SOF1"; process="Extended sequential";
      goto frame;
    case SOF+2:
      str="SOF2"; process="Progressive";
      goto frame;
    case SOF+3:
      str="SOF3"; process="Lossless";
      goto frame;
    case SOF+9:
      str="SOF9"; process="Extended sequential arithmetic";
      goto frame;
    case SOF+10:
      str="SOF10"; process="Progressive arithmetic";
      goto frame;
    case SOF+11:
      str="SOF11"; process="Lossless arithmetic";
      goto frame;
      /* the following SOF markers are for differential coding;
	 they are listed on page B-2 of CD 10918-1, but for some
	 reason are not listed on B-6 and B-7, where the SOF syntax
	 is given.  This suggests that the syntax may be different
	 for these markers, but it doesn't seem to be defined
	 anywhere else in the document.  */
    case SOF+5:
      str="SOF5"; process="Differential sequential";
      goto frame;
    case SOF+6:
      str="SOF6"; process="Differential progressive";
      goto frame;
    case SOF+7:
      str="SOF7"; process="Differential lossless";
      goto frame;
    case SOF+13:
      str="SOF13"; process="Differential sequential arithmetic";
      goto frame;
    case SOF+14:
      str="SOF14"; process="Differential progressive arithmetic";
      goto frame;
    case SOF+15:
      str="SOF15"; process="Differential lossless arithmetic";
      goto frame;
    case DHP:
      str="DHP"; process="Hierarchical";
      
    frame:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("%s (%s) (length %ld)\n", str, process, length);
      totalBytesRead+=2L;
      length-=2L;
      c=getc(stream);
      height=getWordMoto(stream);
      aword=getWordMoto(stream);
      c2=getc(stream);
      totalBytesRead+=6L;
      length-=6L;
      if (verbosity>0) {
	printf("%s  sample precision %d  width %u, height %u  components %d\n",
	       prefix, c, aword, height, c2);
      } else {
	/* even very terse output includes process and dimensions */
	printf("%s  %s JPEG  width %u, height %u  components %d\n", prefix,
	       process, aword, height, c2);
      }
      while (c2--) {
	c3=getc(stream);
	c4=getc(stream);
	c5=getc(stream);
	totalBytesRead+=3L;
	length-=3L;
	if (verbosity>=0)	/* terse output includes sampling factors */
	  printf("%s    id %d horizontal sampling %d, vertical sampling %d, quantization table %d\n", prefix, c3, c4>>4, c4&0x0f, c5);
      }
      break;
    case SOS:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("SOS (length %ld)\n", length);
      totalBytesRead+=2L;
      length-=2L;
      c2=getc(stream);
      totalBytesRead++;
      length--;
      if (verbosity>0)
	printf("%s  components %d\n", prefix, c2);
      while (c2--) {
	c3=getc(stream);
	c4=getc(stream);
	totalBytesRead+=2L;
	length-=2L;
	if (verbosity>0)
	  printf("%s    id %d dc table %d, ac table %d\n", prefix,
		 c3, c4>>4, c4&0x0f);
      }
      c=getc(stream);
      c2=getc(stream);
      c3=getc(stream);
      totalBytesRead+=3L;
      length-=3L;
      if (verbosity>0)
	printf("%s  Ss=%d, Se=%d, Ah=%d, Al=%d\n",
	       prefix, c, c2, c3>>4, c3&0x0f);
      if (nextRSTexpected >= 0)
	nextRSTexpected = 0;	/* reset RST count to 0 if expecting RSTs */
      expectingData=1;		/* compressed data segment begins here */
      break;
    case DQT:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("DQT (length %ld)\n", length);
      totalBytesRead+=2L;
      length-=2L;

      while (length>0L) {
	int tableindex, coefindex, row, col;
	unsigned int table[64];
	int *reftable = NULL;
	double cumsf = 0.0, cumsf2 = 0.0;
	int allones = 1;
	
	c=getc(stream);
	totalBytesRead++;
	length--;
	tableindex = c & 0x0f;
	if (verbosity>0)
	  printf("%s  table %d precision %d\n", prefix, tableindex,
		 (c>>4) ? 16 : 8);
	if (tableindex < 2)
	  reftable = deftabs[tableindex];
	/* Read in the table, compute statistics relative to reference table */
	for (coefindex = 0; coefindex < 64; coefindex++) {
	  unsigned int val;
	  if (c>>4) {
	    val=getWordMoto(stream);
	    totalBytesRead+=2L;
	    length-=2L;
	  } else {
	    val=(unsigned int) getc(stream);
	    totalBytesRead++;
	    length--;
	  }
	  table[coefindex] = val;
	  if (reftable) {
	    double x;
	    /* scaling factor in percent */
	    x = 100.0 * (double)val / (double)reftable[coefindex];
	    cumsf += x;
	    cumsf2 += x * x;
	    /* separate check for all-ones table (Q 100) */
	    if (val != 1) allones = 0;
	  }
	}
	/* If requested, print table in normal array order */
	if (verbosity>1)
	  for (row=0; row<8; row++) {
	    printf("%s    ", prefix);
	    for (col=0; col<8; col++) {
	      printf("%5u ", table[jpeg_zigzag_order[row*8+col]]);
	    }
	    printf("\n");
	  }
	/* Print summary stats */
	if (reftable && verbosity>=0) { /* terse output includes quality */
	  double qual, var;
	  cumsf /= 64.0;	/* mean scale factor */
	  cumsf2 /= 64.0;
	  var = cumsf2 - (cumsf * cumsf); /* variance */
	  if (allones)		/* special case for all-ones table */
	    qual = 100.0;
	  else if (cumsf <= 100.0)
	    qual = (200.0 - cumsf) / 2.0;
	  else
	    qual = 5000.0 / cumsf;
	  printf("%s  Approximate quality factor for qtable %d: %.0f (scale %.2f, var %.2f)\n", prefix,
		 tableindex, qual, cumsf, var);
	}
      }
      break;
    case DHT:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("DHT (length %ld)\n", length);
      totalBytesRead+=2L;
      length-=2L;
      while (length>0L) {
	unsigned char numsymsoflen[16];
	unsigned char symlength[256];
	int duplicatecodes = 0;
	c=getc(stream);
	totalBytesRead++;
	length--;
	if (verbosity>0)
	  printf("%s  table %d\n", prefix, c);
	for (i=0; i<16; i++) {
	  numsymsoflen[i]=(unsigned char) getc(stream);
	}
	totalBytesRead+=16L;
	length-=16L;
	for (i=0; i<256; i++) {
	  symlength[i] = 0;
	}
	for (i=0; i<16; i++) {
	  if (verbosity>3)
	    printf("%s    bits %2d (codes=%3u)", prefix, i+1,
		   (unsigned int) numsymsoflen[i]);
	  while (numsymsoflen[i]--) {
	    c2 = getc(stream);
	    totalBytesRead++;
	    length--;
	    if (symlength[c2])
	      duplicatecodes++;
	    symlength[c2] = i+1;
	    if (verbosity>3)
	      printf(" $%02x", c2);
	  }
	  if (verbosity>3)
	    printf("\n");
	}
	if (duplicatecodes && verbosity>0)
	  printf("%s    %d symbols were assigned multiple codes!\n", prefix,
		 duplicatecodes);
	if (verbosity>2) {	/* produce the summary table */
	  int lastnz, cursym;
	  for (lastnz = 255; lastnz > 0; lastnz--) {
	    if (symlength[lastnz]) break;
	  }
	  printf("%s    code lengths assigned to symbols:\n",
		 prefix);
	  printf("%s        x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF\n",
		 prefix);
	  for (cursym = 0; cursym <= lastnz; cursym += 16) {
	    printf("%s    %Xx ", prefix, cursym >> 4);
	    for (i=0; i<16; i++) {
	      if (symlength[cursym+i])
		printf("%3d", symlength[cursym+i]);
	      else
		printf("   ");
	    }
	    printf("\n");
	  }
	}
      }
      break;
    case DAC:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("DAC (length %ld)\n", length);
      totalBytesRead+=2L;
      length-=2L;
      while (length>0L) {
	c=getc(stream);
	c2=getc(stream);
	totalBytesRead+=2L;
	length-=2L;
	if (verbosity>0)
	  printf("%s  id %d conditioning %d\n", prefix, c, c2);
      }
      break;
    case RST+0:
    case RST+1:
    case RST+2:
    case RST+3:
    case RST+4:
    case RST+5:
    case RST+6:
    case RST+7:
      thisRSTnum = marker - RST;
      /* RSTs are normally printed at verbosity 5, but an RST occurring
       * outside any compressed data segment will be shown at verbosity 1,
       * as will an out-of-sequence RST.
       */
      if (verbosity>0) {
	if (verbosity>4 || !wasExpectingData || thisRSTnum!=nextRSTexpected) {
	  printf("%soffset $%lx ", prefix, totalBytesRead+startingOffset-2L);
	  printf("RST%d", thisRSTnum);
	  if (thisRSTnum != nextRSTexpected) {
	    if (wasExpectingData && nextRSTexpected >= 0)
	      printf("  Out-of-sequence: RST%d expected", nextRSTexpected);
	    else
	      printf("  No RSTn expected here");
	  }
	  printf("\n");
	}
      }
      nextRSTexpected = (thisRSTnum+1) & 7;
      expectingData=1;		/* compressed data segment continues */
      break;
    case DNL:
      length=(long) getWordMoto(stream);
      aword = getWordMoto(stream);
      if (verbosity>0) {
	printf("DNL (length %ld)\n", length);
	printf("%s  lines %u\n", prefix, aword);
      }
      totalBytesRead+=4L;
      length-=4L;
      break;
    case EOI:
      if (verbosity>0)
	printf("EOI\n");
      break;
    case EXP:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("DHP (length %ld)\n", length);
      c=getc(stream);
      if (verbosity>0)
	printf("%s  horizontal expansion %d, vertical expansion %d\n", prefix,
	       c>>4, c&0x0f);
      totalBytesRead+=3L;
      length-=3L;
      break;
    case TEM:
      if (verbosity>0)
	printf("TEM\n");
      break;
    /* JPEG Part 3 extension markers */
    case VER:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("VER (length %ld)\n", length);
      c=getc(stream);
      c2=getc(stream);
      totalBytesRead+=4L;
      length-=4L;
      if (verbosity>0)
	printf("%s  version %d.%d capabilities:", prefix, c, c2);
      while (length>0L) {
	c=getc(stream);
	totalBytesRead++;
	length--;
	if (verbosity>0)
	  printf(" $%02x", c);
      }
      if (verbosity>0)
	printf("\n");
      break;
    case SRF:
      length=(long) getWordMoto(stream);
      aword = getWordMoto(stream);
      aword2 = getWordMoto(stream);
      if (verbosity>0) {
	printf("SRF (length %ld)\n", length);
	printf("%s  vertical offset %u, horizontal offset %u\n", prefix,
	       aword, aword2);
      }
      totalBytesRead+=6L;
      length-=6L;
      break;
    case SRS:
      length=(long) getWordMoto(stream);
      aword = getWordMoto(stream);
      aword2 = getWordMoto(stream);
      aword3 = getWordMoto(stream);
      aword4 = getWordMoto(stream);
      if (verbosity>0) {
	printf("SRS (length %ld)\n", length);
	printf("%s  vertical offset %u, horizontal offset %u\n", prefix,
	       aword, aword2);
	printf("%s  vertical size %u, horizontal size %u\n", prefix,
	       aword3, aword4);
      }
      totalBytesRead+=10L;
      length-=10L;
      break;
    case DTI:
      length=(long) getWordMoto(stream);
      c=getc(stream);
      aword = getWordMoto(stream);
      aword2 = getWordMoto(stream);
      along = getLongMoto(stream);
      along2 = getLongMoto(stream);
      if (verbosity>0) {
	printf("DTI (length %ld)\n", length);
	printf("%s  tiling type %d, vertical scale %u, horizontal scale %u\n",
	       prefix, (int) c, aword, aword2);
	printf("%s  reference grid height %lu, width %lu\n",
	       prefix, along, along2);
      }
      totalBytesRead+=15L;
      length-=15L;
      break;
    case DTT:
      length=(long) getWordMoto(stream);
      along = getLongMoto(stream);
      along2 = getLongMoto(stream);
      along3 = getLongMoto(stream);
      along4 = getLongMoto(stream);
      if (verbosity>0) {
	printf("DTT (length %ld)\n", length);
	printf("%s  vertical scale %lu, horizontal scale %lu\n",
	       prefix, along, along2);
	printf("%s  vertical offset %lu, horizontal offset %lu\n",
	       prefix, along3, along4);
      }
      totalBytesRead+=18L;
      length-=18L;
      break;
    case DCR:
      length=(long) getWordMoto(stream);
      c=getc(stream);
      c2=getc(stream);
      if (verbosity>0) {
	printf("DCR (length %ld)\n", length);
	printf("%s  component %d: vertical offset %d, horizontal offset %d\n",
	       prefix, (int) c, c2>>4, c2&0x0f);
      }
      totalBytesRead+=4L;
      length-=4L;
      break;
    case DQS:
      length=(long) getWordMoto(stream);
      c=getc(stream);
      if (verbosity>0) {
	printf("DQS (length %ld)\n", length);
	printf("%s  Tc %d\n", prefix, (int) c);
      }
      totalBytesRead+=3L;
      length-=3L;
      break;
    default:
      length=(long) getWordMoto(stream);
      if (verbosity>0)
	printf("marker $%02x (length %ld)\n", marker, length);
      totalBytesRead+=2L;
      length-=2L;
      if (verbosity>0)
	printf("%s  ", prefix);
      while (length>0L) {
	c=getc(stream);
	totalBytesRead++;
	length--;
	if (verbosity>0)
	  printChar(c);
      }
      if (verbosity>0)
	printf("\n");
      break;
    } /* end switch (marker) */
    if (length && verbosity>0)
      printf("%s  bad length (residual=%ld)\n", prefix, length);
    if (marker==EOI && !continueAfterEOI)
      break;
  } /* end while */

  /* Gripe about extraneous data after last marker */
  if (extraneousBytes && verbosity>0) {
      printf("%s%ld extraneous bytes after last marker\n", prefix,
	     extraneousBytes);
  }

  return totalBytesRead;
}


/* JFIF-defined APPn markers */


static long
dumpAPP0Marker (FILE *stream, char *prefix, int verbosity,
		long startingOffset, long length)
{
  /* Note passed length is bytes *remaining* after the length word;
   * also, startingOffset points to byte after length word.
   * Return the number of bytes consumed; anything remaining in the APP
   * marker will be printed by dumpMarkers.
   */
  long totalBytesRead = 0L;
  char signature[5];
  int i;

  if (length>=5L) {
    for (i=0; i<5; i++)
      signature[i] = getc(stream);
    totalBytesRead+=5L;
    length-=5L;
    if (memcmp(signature, "JFIF", 5)==0 && length>=9L) {
      unsigned int jfifversion, dpiX, dpiY, thumbX, thumbY;
      int dpiUnits;
      long thumbBytes;
	  
      jfifversion = getWordMoto(stream);
      dpiUnits=getc(stream);
      dpiX=getWordMoto(stream);
      dpiY=getWordMoto(stream);
      thumbX=(unsigned int) getc(stream);
      thumbY=(unsigned int) getc(stream);
      totalBytesRead+=9L;
      length-=9L;
      if (verbosity>0) {
	printf("%s  JFIF version %04x, ", prefix, jfifversion);
	switch (dpiUnits) {
	case 0:
	  printf("aspect ratio %u:%u\n", dpiX, dpiY);
	  break;
	case 1:
	  printf("%u x %u dpi\n", dpiX, dpiY);
	  break;
	case 2:
	  printf("%u x %u dpcm\n", dpiX, dpiY);
	  break;
	default:
	  printf("bogus aspect ratio code %d %u %u\n", dpiUnits, dpiX, dpiY);
	  break;
	}
	printf("%s  thumbnail size %u x %u\n", prefix, thumbX, thumbY);
      }
      thumbBytes = (long)thumbX*(long)thumbY*3L;
      totalBytesRead+=thumbBytes;
      length-=thumbBytes;
      while (thumbBytes--)
	getc(stream);
    } else if (memcmp(signature, "JFXX", 5)==0 && length > 0L) {
      int extension;
      unsigned int thumbX, thumbY;
      long thumbBytes;
	  
      extension=getc(stream);
      totalBytesRead++;
      length--;
      switch (extension) {
      case 0x10:
	if (verbosity>0)
	  printf("%s  JFIF extension JPEG thumbnail\n", prefix);
	if (recurseIntoThumbnails) {
	  long bytes;
	  char *newPrefix;
	  newPrefix=(char *) malloc(strlen(prefix)+5);
	  if (newPrefix==NULL) {
	    fprintf(stderr, "out of memory\n");
	    exit(-1);
	  }
	  strcpy(newPrefix, prefix);
	  strcat(newPrefix, "    ");
	  bytes=dumpMarkers(stream, newPrefix, verbosity-1,
			    false, startingOffset+totalBytesRead);
	  totalBytesRead+=bytes;
	  length-=bytes;
	  free(newPrefix);
	} else {
	  while (length>0L) {
	    getc(stream);
	    totalBytesRead++;
	    length--;
	  }
	}
	break;
      case 0x11:
	if (verbosity>0)
	  printf("%s  JFIF extension 1 byte/pixel thumbnail\n", prefix);
	thumbX=(unsigned int) getc(stream);
	thumbY=(unsigned int) getc(stream);
	totalBytesRead+=2L;
	length-=2L;
	if (verbosity>0)
	  printf("%s    thumbnail size %u x %u\n", prefix, thumbX, thumbY);
	if (verbosity>3)
	  printf("%s    palette:\n", prefix);
	for (i=0; i<256; i++) {
	  int red, green, blue;
	  red=getc(stream);
	  green=getc(stream);
	  blue=getc(stream);
	  totalBytesRead+=3L;
	  length-=3L;
	  if (verbosity>3)
	    printf("%s      %3d %3d %3d\n", prefix, red, green, blue);
	}
	thumbBytes = (long)thumbX*(long)thumbY;
	totalBytesRead+=thumbBytes;
	length-=thumbBytes;
	while (thumbBytes--)
	  getc(stream);
	break;
      case 0x13:
	if (verbosity>0)
	  printf("%s  JFIF extension 3 byte/pixel thumbnail\n", prefix);
	thumbX=(unsigned int) getc(stream);
	thumbY=(unsigned int) getc(stream);
	totalBytesRead+=2L;
	length-=2L;
	if (verbosity>0)
	  printf("%s    thumbnail size %u x %u\n", prefix, thumbX, thumbY);
	thumbBytes = (long)thumbX*(long)thumbY*3L;
	totalBytesRead+=thumbBytes;
	length-=thumbBytes;
	while (thumbBytes--)
	  getc(stream);
	break;
      default:
	if (verbosity>0)
	  printf("%s  JFIF extension $%02x\n", prefix, extension);
	break;
      }
    } else {
      /* Unrecognized APP0 marker: dump it out */
      if (verbosity>0) {
	printf("%s  ", prefix);
	for (i=0; i<5; i++)
	  printChar((int) signature[i]);
      }
      while (length>0L) {
	int c = getc(stream);
	if (verbosity>0)
	  printChar(c);
	totalBytesRead++;
	length--;
      }
      if (verbosity>0)
	printf("\n");
    }
  }
  return totalBytesRead;
}


/* SPIFF-defined APPn markers */


static char *
spiffColorSpace (int colorspace)
/* convert SPIFF colorspace code to readable string */
{
  static char mybuf[32];

  switch (colorspace) {
  case 0: return "Bilevel (1=black)";
  case 1: return "YCbCr (709)";
  case 3: return "YCbCr (JFIF)";
  case 4: return "YCbCr (601-1)";
  case 8: return "Grayscale";
  case 9: return "PhotoYCC";
  case 10: return "RGB";
  case 11: return "CMY";
  case 12: return "CMYK";
  case 13: return "YCCK";
  case 14: return "CIELab";
  case 15: return "Bilevel (1=white)";
  }
  sprintf(mybuf, "%d (unknown)", colorspace);
  return mybuf;
}

static char *
spiffCompressType (int compresstype)
/* convert SPIFF compression type code to readable string */
{
  static char mybuf[32];

  switch (compresstype) {
  case 0: return "Uncompressed";
  case 1: return "CCITT MH";
  case 2: return "CCITT MR";
  case 3: return "CCITT MMR";
  case 4: return "JBIG";
  case 5: return "JPEG";
  }
  sprintf(mybuf, "%d (unknown)", compresstype);
  return mybuf;
}

static char *
spiffTranChar (int tranchar)
/* convert SPIFF transfer characteristic code to readable string */
{
  static char mybuf[32];

  switch (tranchar) {
  case 1: return "BT 709";
  case 2: return "Unspecified";
  case 4: return "System M (gamma 2.2)";
  case 5: return "System B,G (gamma 2.8)";
  case 6: return "SMPTE 170M";
  case 7: return "SMPTE 240M";
  case 8: return "Linear (gamma 1.0)";
  }
  sprintf(mybuf, "%d (unknown)", tranchar);
  return mybuf;
}


static long
dumpAPP8Marker (FILE *stream, char *prefix, int verbosity,
		long startingOffset, long length, boolean *inSPIFFDir)
{
  /* Note passed length is bytes *remaining* after the length word;
   * also, startingOffset points to byte after length word.
   * Return the number of bytes consumed; anything remaining in the APP
   * marker will be printed by dumpMarkers.
   */
  long totalBytesRead = 0L;
  char *strname = NULL;
  unsigned long etag, dataptr;
  boolean discard;
  int i, c;

  if (!*inSPIFFDir && length>=30L) {
    /* Check for SPIFF header */
    char signature[6];
    for (i=0; i<6; i++)
      signature[i] = getc(stream);
    totalBytesRead+=6L;
    length-=6L;
    if (memcmp(signature, "SPIFF", 6)==0) {
      unsigned int spiffversion;
      int profile, numcomponents, colorspace, bps, compresstype, dpiUnits;
      unsigned long height, width, vres, hres;

      spiffversion=getWordMoto(stream);
      profile=getc(stream);
      numcomponents=getc(stream);
      height=getLongMoto(stream);
      width=getLongMoto(stream);
      colorspace=getc(stream);
      bps=getc(stream);
      compresstype=getc(stream);
      dpiUnits=getc(stream);
      vres=getLongMoto(stream);
      hres=getLongMoto(stream);
      totalBytesRead+=24L;
      length-=24L;
      if (verbosity>0) {
	printf("%s  SPIFF version %04x, profile %d, image %luh x %luw x %d\n",
	       prefix, spiffversion, profile, height, width, numcomponents);
	printf("%s  colorspace %s, bits/sample %d, compression %s\n", prefix,
	       spiffColorSpace(colorspace), bps,
	       spiffCompressType(compresstype));
	printf("%s  ", prefix);
	switch (dpiUnits) {
	case 0:
	  printf("aspect ratio %lu:%lu\n", vres, hres);
	  break;
	case 1:
	  printf("%lu x %lu dpi\n", vres, hres);
	  break;
	case 2:
	  printf("%lu x %lu dpcm\n", vres, hres);
	  break;
	default:
	  printf("bogus aspect ratio code %d %lu %lu\n", dpiUnits, vres, hres);
	  break;
	}
      }
      *inSPIFFDir = true;
    } else {
      /* Unrecognized APP8 marker: dump it out */
      if (verbosity>0) {
	printf("%s  ", prefix);
	for (i=0; i<6; i++)
	  printChar((int) signature[i]);
      }
      while (length>0L) {
	c = getc(stream);
	if (verbosity>0)
	  printChar(c);
	totalBytesRead++;
	length--;
      }
      if (verbosity>0)
	printf("\n");
    }
    return totalBytesRead;
  }

  if (!*inSPIFFDir || length < 4L)
    return totalBytesRead;

  etag = getLongMoto(stream);
  totalBytesRead+=4L;
  length-=4L;
  discard = false;

  if (verbosity>0) {
    /* except for EOD, total size of directory entries should be mult of 4 */
    if (etag == 1) {
      if (length != 2L)
	printf("%s  Unexpected length for SPIFF EOD\n", prefix);
    } else {
      if ((length & 3) != 0)
	printf("%s  SPIFF directory entry is not a multiple of 4 bytes long\n",
	       prefix);
    }
  }

  switch (etag) {
  case 1:			/* EOD */
    if (verbosity>0) {
      printf("%s  SPIFF EOD\n", prefix);
    }
    /* check for dummy SOI */
    if (length == 2L) {
      unsigned int aword = getWordMoto(stream);
      totalBytesRead+=2L;
      length-=2L;
      if (aword != 0xffd8 && verbosity>0)
	printf("%s  EOD contents $%04x, should be $ffd8\n", prefix, aword);
    }
    *inSPIFFDir = false;
    break;
  case 2:			/* TRANCHAR */
    if (verbosity>0) {
      int tranchar=getc(stream);
      totalBytesRead++;
      length--;
      printf("%s  SPIFF Transfer Characteristic  %s\n", prefix,
	     spiffTranChar(tranchar));
      discard = true;
    }
    break;
  case 3:			/* Component registration */
    if (verbosity>0) {
      printf("%s  SPIFF Component Registration ", prefix);
      while (length>0L) {
	c = getc(stream);
	printf(" $%02x", c);
	totalBytesRead++;
	length--;
      }
      printf("\n");
    }
    break;
  case 4:			/* Image orientation */
    if (verbosity>0) {
      int imgor=getc(stream);
      int imgflip=getc(stream);
      totalBytesRead+=2L;
      length-=2L;
      printf("%s  SPIFF Image Orientation  rotate=%d, flip=%d\n", prefix,
	     imgor, imgflip);
      discard = true;
    }
    break;
  case 5:			/* Thumbnail */
    if (verbosity>0) {
      printf("%s  SPIFF Thumbnail ", prefix);
      printf(" data %lu", getLongMoto(stream));
      printf(" height %u", getWordMoto(stream));
      printf(" width %u\n", getWordMoto(stream));
      printf("%s  colorspace %s,", prefix, spiffColorSpace(getc(stream)));
      printf(" bits/sample %d,", getc(stream));
      printf(" compression %s", spiffCompressType(getc(stream)));
      printf("\n");
      totalBytesRead+=11L;
      length-=11L;
      discard = true;		/* discard contents of thumbnail */
    }
    break;
  case 6:			/* Image title */
    strname = "Image Title";
    goto string_tag;
  case 7:			/* Image description */
    strname = "Image Description";
    goto string_tag;
  case 9:			/* Version */
    strname = "Version";
    goto string_tag;
  case 10:			/* Creator */
    strname = "Creator";
    goto string_tag;
  case 12:			/* Copyright */
    strname = "Copyright";
    goto string_tag;
  string_tag:
    if (verbosity>0) {
      printf("%s  SPIFF %s ", prefix, strname);
      dataptr = getLongMoto(stream);
      printf(" data %lu", dataptr);
      printf(" charset %d\n", getc(stream));
      totalBytesRead+=5L;
      length-=5L;
      if (dataptr != 0L && verbosity < 3)
	discard = true;
      /* else we rely on dumpMarkers to print the string data, if present */
    }
    break;
  case 8:			/* Time stamp */
    if (verbosity>0) {
      printf("%s  SPIFF Time Stamp\n", prefix);
      /* let dumpMarkers print the strings */
    }
    break;
  case 11:			/* Protection */
    if (verbosity>0) {
      int prot=getc(stream);
      totalBytesRead++;
      length--;
      printf("%s  SPIFF Protection Indicator  level %d\n", prefix, prot);
      discard = true;
    }
    break;
  case 13:			/* Contact */
    if (verbosity>0) {
      printf("%s  SPIFF Contact Info ", prefix);
      printf(" country %u", getWordMoto(stream));
      printf(" authority %u", getWordMoto(stream));
      printf(" ID %lu\n", getLongMoto(stream));
      dataptr = getLongMoto(stream);
      printf("%s  data %lu", prefix, dataptr);
      printf(" charset %d\n", getc(stream));
      totalBytesRead+=13L;
      length-=13L;
      if (dataptr != 0L && verbosity < 3)
	discard = true;
      /* else we rely on dumpMarkers to print the string data, if present */
    }
    break;
  case 14:			/* Tile index */
    if (verbosity>0) {
      printf("%s  SPIFF Tile Index ", prefix);
      printf(" location %lu", getLongMoto(stream));
      printf(" count %lu", getLongMoto(stream));
      printf("\n");
      totalBytesRead+=8L;
      length-=8L;
    }
    break;
  case 15:			/* Scan index */
    if (verbosity>0) {
      printf("%s  SPIFF Scan Index ", prefix);
      printf(" location %lu", getLongMoto(stream));
      printf(" count %lu", getLongMoto(stream));
      printf("\n");
      totalBytesRead+=8L;
      length-=8L;
    }
    break;
  case 16:			/* Set reference */
    if (verbosity>0) {
      printf("%s  SPIFF Set Reference ", prefix);
      printf(" refno1 %lu", getLongMoto(stream));
      printf(" refno2 %lu", getLongMoto(stream));
      printf(" refno3 %lu", getLongMoto(stream));
      printf("\n");
      totalBytesRead+=12L;
      length-=12L;
    }
    break;
  default:
    if (verbosity>0) {
      printf("%s  Unknown SPIFF tag %lu\n", prefix, etag);
    }
    break;
  }

  if (discard) {		/* discard any padding bytes */
    while (length>0L) {
      c = getc(stream);
      totalBytesRead++;
      length--;
    }
  }

  return totalBytesRead;
}


/* Adobe Photoshop APPn markers */

/*
 * If the total number of bytes needed exceeds about 32K, Photoshop will
 * divide its data into multiple APP13 markers at arbitrary division
 * points (often within a resource).  Each such marker has the
 * Photoshop signature.  To print the resources legibly when this
 * happens, we separate parsing of the resource stream from parsing
 * of the APPn markers.
 */

static void
parseAdobeResources (int c, char *prefix, int verbosity, long currentOffset)
{
  /* this data is static because it must persist across markers */
  static boolean inHeader = true;
  static int headerBytes = 0;	/* bytes accumulated in resource header */
  static int headerData[256+16]; /* workspace for header accumulation */
  static long resSize = 0L;	/* bytes remaining in resource body */
  static long bodyBytes = 0L;	/* total bytes to read: body + pad */

  int i;

  if (inHeader) {
    headerData[headerBytes++] = c;
    if (headerBytes >= 7) {
      /* 10 bytes fixed data, plus a counted string padded to even length */
      int nameLength = headerData[6];
      int headerSize = nameLength + 11;
      if (headerSize & 1)
	headerSize++;
      if (headerBytes >= headerSize) {
	int resID;
	/* print the OSType as text -- it should always be '8BIM' */
	printf("%s  type ", prefix);
	printCharNoHex(headerData[0]);
	printCharNoHex(headerData[1]);
	printCharNoHex(headerData[2]);
	printCharNoHex(headerData[3]);
	resID = (headerData[4] << 8) + headerData[5];
	printf(" ID $%04X name '", resID);
	for (i = 0; i < nameLength; i++) {
	  printChar(headerData[7+i]);
	}
	resSize = headerData[headerSize-4];
	resSize = (resSize << 8) + headerData[headerSize-3];
	resSize = (resSize << 8) + headerData[headerSize-2];
	resSize = (resSize << 8) + headerData[headerSize-1];
	printf("' size %ld offset %ld\n", resSize, currentOffset+1L);
	if (resSize > 0L) {
	  inHeader = false;
	  bodyBytes = resSize;
	  if (bodyBytes & 1L)	/* account for padding to even length */
	    bodyBytes++;
	  if (verbosity>2)
	    printf("%s    ", prefix);
	} else {
	  inHeader = true;
	  headerBytes = 0;
	}
      }
    }
  } else {
    /* in resource body */
    if (resSize > 0L && verbosity>2)
      printChar(c);
    resSize--;
    if (--bodyBytes <= 0L) {
      if (verbosity>2)
	printf("\n");
      inHeader = true;
      headerBytes = 0;
    }
  }
}

static long
dumpAPP13Marker (FILE *stream, char *prefix, int verbosity,
		 long startingOffset, long length)
{
  /* Note passed length is bytes *remaining* after the length word;
   * also, startingOffset points to byte after length word.
   * Return the number of bytes consumed; anything remaining in the APP
   * marker will be printed by dumpMarkers.
   */
  long totalBytesRead = 0L;
#define SIGLENGTH 14
  char signature[SIGLENGTH];
  int i;

  if (length >= (long)SIGLENGTH && verbosity>0) {
    for (i=0; i<SIGLENGTH; i++)
      signature[i] = getc(stream);
    totalBytesRead+=SIGLENGTH;
    length-=SIGLENGTH;
    if (memcmp(signature, "Photoshop 3.0", SIGLENGTH)==0) {
      printf("%s  Photoshop 3.0 image resources:\n", prefix);
      while (length > 0) {
	int c = getc(stream);
	if (c == EOF)
	  break;
	parseAdobeResources(c, prefix, verbosity,
			    startingOffset+totalBytesRead);
	totalBytesRead++;
	length--;
      }
      if (length) {		/* oops */
	printf("%s  APP13 marker overran end of file by %ld bytes\n", prefix,
	       length);
      }
    } else {
      /* Unrecognized APP13 marker: dump it out */
      if (verbosity>0) {
	printf("%s  ", prefix);
	for (i=0; i<SIGLENGTH; i++)
	  printChar((int) signature[i]);
      }
      while (length>0L) {
	int c = getc(stream);
	if (verbosity>0)
	  printChar(c);
	totalBytesRead++;
	length--;
      }
      if (verbosity>0)
	printf("\n");
    }
  }
  return totalBytesRead;
#undef SIGLENGTH
}


/* Utility routines */


static unsigned int
getWordMoto (FILE *stream)
/* fetch 16-bit field */
{
  register unsigned int temp;

  temp=(unsigned int) (getc(stream)<<8);
  return (unsigned int) getc(stream) | temp;
}

static unsigned long
getLongMoto (FILE *stream)
/* fetch 32-bit field */
{
  register unsigned long temp;

  temp=(unsigned long) getc(stream);
  temp=(temp << 8) | (unsigned long) getc(stream);
  temp=(temp << 8) | (unsigned long) getc(stream);
  temp=(temp << 8) | (unsigned long) getc(stream);
  return temp;
}

static void
printChar (int c)
{
  if (hexchars)
    printf("$%02x ", c);
  else
    printCharNoHex(c);
}

static void
printCharNoHex (int c)
{
  if (c == '\\')
    printf("\\\\");
  else if (isprint(c) || c == '\n')
    putchar(c);
  else
    printf("\\%03o", c);
}
